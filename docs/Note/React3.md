---
group: React
title: 组件的通信方式和合成事件机制
order: 3
---

## react 组件的通信方式

- 父——>子：props
- 子——>父：回调函数
- 跨层级组件之间：层层传递、useContext
- 相邻组件之间：传递到同一个父组件
- 非嵌套关系组件：状态管理库 redux、zustand 等

## react 合成事件机制

### 事件传播机制

js 中的事件传播机制有三个阶段：捕获阶段、目标阶段、冒泡阶段。
之所以设置捕获阶段和冒泡阶段是为了让开发者可以在不同层级的元素上处理事件。

- 捕获阶段：当某个元素触发某个事件（如 onclick ），顶层对象 document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。
- 目标阶段：执行阶段。
- 冒泡阶段：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。如果想阻止事件起泡，可以使用 e.stopPropagation() 或者 e.cancelBubble=true（IE）来阻止事件的冒泡传播。

### 事件委托

将响应事件绑定到另一个元素（父元素、祖先元素）。
当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理。

### 浏览器事件差异

由于浏览器厂商的实现差异，在事件的属性及方法在不同浏览器及版本上略有不同，开发者为兼容各浏览器及版本之间的差异，需要编写兼容代码，要么重复编写模板代码，要么将磨平浏览器差异的方法提取出来。

### react 实现合成事件机制的好处

- 将事件绑定到根节点，减少了事件监听器的简历，节省内存
- 磨平不同浏览器差异。
- 对开发者友好。

### 实现细节

React 对原生事件和合成事件进行了分类对应，例如`onChange`合成事件，它依赖了['change','click','focusin','focusout','input','keydown','keyup','selectionchange']原生事件。
再根据原生事件是否具有冒泡阶段，分为可代理事件和非代理事件。
对于可代理事件，会在根节点上绑定捕获阶段和冒泡阶段的监听器。对于非代理事件，在根节点只绑定捕获阶段的监听器，在目标元素上添加响应的冒泡阶段监听器。
实际上，对于非代理事件，react 都进行了冒泡模拟。

那么原生事件和合成事件之间的区别在哪？
React 的合成事件是基于事件委托的，由此可见是在冒泡阶段执行相应事件。而元素事件是在目标阶段，先于合成事件。（俩者不要一起用）
同时对于合成事件的阻止冒泡，只要使用 e.stopPropagation()，不用考虑浏览器之间的差异。
